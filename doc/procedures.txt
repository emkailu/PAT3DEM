# procedures to process electron microscopy (EM) data

1. be organized
1)create one folder for one project, usually named by specimen and magnification, e.g., 'Mtb70S-29K/'
2)under the project folder, use subfolders, e.g., 'Rawmovies/' for raw movie stacks
3)under subfolders, use subsubfolder, usually named by date, e.g., '20150911/'
4)under subsubfolder, use a UNIQUE name for each micrograph, usually named by date and a serial number, e.g., 20150911_001.dm4
5)three e.g.:
'Mtb70S-29K/Rawmovies/20150911/20150911_001.dm4'
'Mtb70S-29K/Micrographs/20150911/20150911_001.mrc'
'Mtb70S-29K/Micrographs/bad/20150912_005.mrc'

2. preprocess movies
***mag_distortion_correct
correct anisotropic magnification distortion, see Zhao et al., 2015 and Grant & Grigorieff, 2015

***p3movie.py
1)align frames (ITERATIVELY align each frame with the current best total sum)
2)apply a dose-dependent filter (RNA/DNA tolerate ~2 times higher dose than proteins)
3)output unfiltered fulldose sum (for ctf), filtered fulldose/lowdose sum, filtered lowdose averaged movies
4)lowdose may also exclude the first few frames (~0.5s) due to beam induced drift, otherwise, during averaging adjacent frames, do not average them with later frames, then they can be weighted in relion movie processing
5)if the movies have different number of frames, e.g. 100 movies have 50 frames, another 100 movies have 25 frames, then the best way is to run a 50-frame movie processing for the 100  movies and another 25-frame movie processing for the 200 movies. Finally merge the shiny particles. The option '-s2' is designed for this purpose
6)also be aware that it's better to do movie processing seperately for counting and superresolution data
7)for faster processing (at the speed of data transfer), submit a job running ***p3movierun.py to cluster, and then run ***p3downloadrun.sh locally

3. ctf
***gctf
1)locally refine to get the defocus for each particle
2)high resolution refine

***p3ctf.py
1)based on fulldose sum
2)contribution of amplitude contrast is 5%–10% for cryo-EM, but practically use 10%, or even higher values to 20%

***p3defscreen.py
screen based on the defocus value output by p3ctf.py

4. locate particles
***e2boxer
1)low-pass filter to see the particles clearly
2)erase: ①bad area; ②big no-particle area
3)swarm tool:
①box size: ideally D+2R, R=λΔF/d, see Rosenthal & Henderson, 2003. D is diameter of particles, λ=0.025Å for 200 keV, ΔF is defocus, d is target resolution
②change threshold so that visible particles are not excluded
③delete bad boxes (if the whole micrograph is bad, clear boxes)
④finish one micrograph before processing the next
4)exclude bad micrographs (boxes cleared to 0)

***p3starcoord.py
get coordinates from star files, consider _rlnOriginX and _rlnOriginY if they are in the star files

***p3starmerge.py
1)merge star files containning particles, and regroup
2)regroup, if only one star file was given

5. screen micrographs
***p3micscreen.py
1)screen based on outputs of p3movie.py and p3ctf.py, modulated by number of particles and defocus
2)the underlying assumptions are: 
①the score of p3movie.py represents how well the frames can be aligned. If the alignment of frames is not good, neither will be the alignment of particles, though relion movie processing may help if the bad alignment is caused by different per-particle drift
②the score of p3ctf.py represents how far the Thon rings can go
3)need to be modulated by sqrt(numptcl) and/or defocus
4)sigma based cutoff
5)sig = sig(unblur/sqrt(nump)/defocus) * weight1 + sig(1/thon/sqrt(nump)) * weight2
6)double-check is necessary
7)gradually exclude bad micrographs after classification/refinement

6.

?. screen particles
***p3starscreen.py
Write two new star files after screening by an item in the star file

?.modeling
***p3pdbdev.py
output pdb1, whose bfactor is replaced by CA deviation between pdb1 and pdb2

?.interpret
***p3xml.py
convert xml to txt and optionally display them

***p3recrand.py
reconstruct from randomly selected particles from _data.star

***p3cuboidgen.py
generate a cuboid on the grid of input image

***p3cuboidvalue.py
output the values of voxels within a coordinate range, 'x1 x2 y1 y2 z1 z2'


FOR REFERENCES, PLEASE RUN INDIVIDUAL PROGRAMS WITHOUT ANY OPTIONS.
